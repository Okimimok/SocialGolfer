import intree
import numpy as np

# For all functions below, it is assumed that the nodes/products in the tree
# are indexed 0, 1,..., n-1 for a tree of size n

# INPUTS
# tree: an InTree representing the possible customer classes
# rev: a list where rev[i] is the revenue of product i
# cost: a list where cost[i] is the cost of offering product i
# f: a list where f[i] is the substitution cost of a customer getting their
#    ith choice product
# cust_classes: a list where cust_classes[k] = [i, j, p] represents
#   a customer class that follows the path from i to j and this customer class
#   occurs with probability p

# preprocess calculates:
# Rev[i] = the total revenue generated by product i if no ancestors of i are
#   offered
# Rev_Sub[i][j] = the total revenue stolen from product j is we offer i above it
# Pen[i] = the total substution penalities generated by product i if no ancestors
#   of i are offered
# Pen_Sub[i][j] = the total substituion penalties removed if we offer product i
#   above product j
def preprocess(tree, rev, f, cust_classes):
    n = tree.size()
    Rev = np.zeros(shape=(n))
    Rev_Sub = np.zeros(shape=(n,n))
    Pen = np.zeros(shape=(n))
    Pen_Sub = np.zeros(shape=(n,n))
    
    
    for g in cust_classes:
        path = tree.get_path(g[0],g[1])
        prob = g[2]
        
        m = len(path)
        for x in range(m):
            i = path[x]
            Rev[i] += prob*rev[i]
            Pen[i] += prob*f[x]
            
            for y in range(x,m):
                j = path[y]
                Rev_Sub[i][j] += prob*rev[j]
                Pen_Sub[i][j] += prob*f[y]

    return Rev, Rev_Sub, Pen, Pen_Sub

# generate_subset looks at the optimal choices found by the DP and generates
# the optimal subset in i's ancestor tree given that j is the closest successor
# of i to be offered (j = n represents the empty set)
def generate_subset(tree, i, j, Picked):
    node = tree.get_node(i)
    rparent, lparent = node.rparent(), node.lparent()

    subset = []
    picked = Picked[i,j]
    if picked:
        subset.append(i)
    if (rparent is not None):
        if picked:
            subset.extend(generate_subset(tree, rparent, i, Picked))
        else:
            subset.extend(generate_subset(tree, rparent, j, Picked))
    if (lparent is not None):
        if picked:
            subset.extend(generate_subset(tree, lparent, i, Picked))
        else:
            subset.extend(generate_subset(tree, lparent, j, Picked))
            
    return subset

# DP returns the product assortment that optimizes profit
def DP(tree, rev, cost, f, cust_classes):
    n = tree.size()

    # Values[i][j] represents the maximum revenue from i's ancestor
    # tree given j is the closest successor of i offered minus the revenue
    # blocked from j (j = n represents the empty set)
    # Picked[i][j] represents whether or not to offer i in this scenario
    Values = np.zeros(shape = (n,n+1))
    Picked = np.zeros(shape = (n,n+1))

    Rev, Rev_Sub, Pen, Pen_Sub = preprocess(tree, rev, f, cust_classes)
    ordered_pairs = tree.get_ordered_pairs()

    for [i,j] in ordered_pairs:
        if j == 'empty':
            j = n
            
        node = tree.get_node(i)
        rparent, lparent = node.rparent(), node.lparent()

        not_choose = 0
        choose = Rev[i]-cost[i]-Pen[i]
        if j != n:
            choose += -Rev_Sub[i][j]+Pen_Sub[i][j]
        if rparent is not None:
            not_choose += Values[rparent][j] 
            choose += Values[rparent][i] 
        if lparent is not None:
            not_choose += Values[lparent][j]
            choose += Values[lparent][i]

        Values[i][j] = max(not_choose, choose)
        Picked[i][j] = (choose > not_choose)

    return generate_subset(tree,n-1,n,Picked), Values[n-1][n]

# An example problem
if __name__ == "__main__":
    tree = intree.InTree()
    tree.add_node(0)
    tree.add_node(1,0)
    tree.add_node(2)
    tree.add_node(3,2,1)
    tree.add_node(4,3)

    rev = [1, 0.5, 3, 2, 1]
    costs = [0, 0, 0, 0, 0]
    f = [0, 0, 0, 0]
    cust_classes = [[0,4,0.5],[2,4,0.5]]

    print DP(tree, rev, costs, f, cust_classes)
        
    
                
        
    
